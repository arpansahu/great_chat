pipeline {
    agent { label 'local' }
    parameters {
        booleanParam(name: 'skip_checks', defaultValue: true, description: 'Skip the Check for Changes stage')
        choice(name: 'DEPLOY_TYPE', choices: ['docker', 'kubernetes'], description: 'Select deployment type')
    }
    environment {
        REGISTRY = "harbor.arpansahu.me"
        REPOSITORY = "library/great_chat"
        IMAGE_TAG = "latest"  // Optionally, this could be set dynamically to support CI/CD best practices
        KUBECONFIG = "${env.WORKSPACE}/kubeconfig"  // Set the KUBECONFIG environment variable securely
        NGINX_CONF = "/etc/nginx/sites-available/great-chat"
    }
    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "Current workspace path is: ${env.WORKSPACE}"
                }
            }
        }
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Setup Kubernetes Config') {
            when {
                expression { return params.DEPLOY_TYPE == 'kubernetes' }
            }
            steps {
                script {
                    // Ensure the kubeconfig is securely copied and permissions set
                    sh "sudo cp /root/.kube/config ${env.WORKSPACE}/kubeconfig"
                    sh "sudo chmod 644 ${env.WORKSPACE}/kubeconfig"
                }
            }
        }
        stage('Check for New Image') {
            when {
                expression { !params.skip_checks }
            }
            steps {
                script {
                    // Checking for the new Docker image
                    def currentImageID = sh(script: "docker inspect -f '{{.Image}}' great_chat || echo 'none'", returnStdout: true).trim()
                    echo "Current image ID: ${currentImageID}"

                    sh "docker pull ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}"
                    def latestImageID = sh(script: "docker inspect -f '{{.Id}}' ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}", returnStdout: true).trim()
                    echo "Latest image ID: ${latestImageID}"

                    if (currentImageID != latestImageID) {
                        env.NEW_IMAGE_AVAILABLE = 'true'
                        echo "New image available, proceeding with deployment."
                    } else {
                        env.NEW_IMAGE_AVAILABLE = 'false'
                        echo "No new image available, skipping deployment."
                    }
                }
            }
        }
        stage('Deploy') {
            when {
                expression {
                    return params.skip_checks || env.NEW_IMAGE_AVAILABLE == 'true'
                }
            }
            steps {
                script {
                    if (params.DEPLOY_TYPE == 'docker') {
                        sh "sed -i 's|image: .*|image: ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}|' docker-compose.yml"
                        sh 'docker-compose down'
                        sh 'docker-compose up -d'

                        sleep 10  // Giving the service time to start

                        def containerRunning = sh(script: "docker ps -q -f name=great_chat", returnStdout: true).trim()
                        if (!containerRunning) {
                            error "Container great_chat is not running"
                        } else {
                            echo "Container great_chat is running"

                            // Retry logic to ensure the service is reachable
                            for (int i = 0; i < 5; i++) {
                                def response = sh(script: "curl -s -o /dev/null -w '%{http_code}' http://0.0.0.0:8002", returnStdout: true).trim()
                                if (response == '200') {
                                    echo "Service is up and running."
                                    break
                                }
                                if (i < 4) {
                                    echo "Service not ready, retrying in 10 seconds..."
                                    sleep 10
                                } else {
                                    error "Service failed to start after multiple attempts."
                                }
                            }
                        }
                    } else if (params.DEPLOY_TYPE == 'kubernetes') {
                        sh "sudo cp /root/projectenvs/great_chat/.env ${env.WORKSPACE}/"

                        if (fileExists("${env.WORKSPACE}/.env")) {
                            echo ".env file copied successfully."
                            sh 'kubectl cluster-info'
                            sh 'pwd'
                            sh "kubectl delete secret great-chat-secret || true"
                            sh "kubectl create secret generic great-chat-secret --from-env-file=${WORKSPACE}/.env"
                            sh "kubectl apply -f ${WORKSPACE}/deployment.yaml"
                            sh "kubectl apply -f ${WORKSPACE}/service.yaml"
                            sh "kubectl rollout status deployment/great-chat-app"

                            def nodePort = sh(script: "kubectl get service great-chat-service -o=jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()
                            def clusterIP = sh(script: "kubectl get nodes -o=jsonpath='{.items[0].status.addresses[0].address}'", returnStdout: true).trim()

                            sh "curl -v http://${clusterIP}:${nodePort}"

                            sh "sudo sed -i 's|proxy_pass .*;|proxy_pass http://${clusterIP}:${nodePort};|' ${NGINX_CONF}"
                            sh "sudo nginx -s reload"
                        } else {
                            error ".env file not found in the workspace."
                        }
                    }
                    currentBuild.description = 'DEPLOYMENT_EXECUTED'
                }
            }
        }
    }
    post {
        success {
            script {
                sh '''
                curl -s -X POST --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET https://api.mailjet.com/v3.1/send -H "Content-Type:application/json" -d '{
                    "Messages":[
                        {
                            "From": {
                                "Email": "$MAIL_JET_EMAIL_ADDRESS",
                                "Name": "ArpanSahuOne Jenkins Notification"
                            },
                            "To": [
                                {
                                    "Email": "$MY_EMAIL_ADDRESS",
                                    "Name": "Development Team"
                                }
                            ],
                            "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Ran Successfully",
                            "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed",
                            "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed </h3> <br> <p> Build Url: ${env.BUILD_URL} </p>"
                        }
                    ]
                }'
                '''
            }
        }
        failure {
            script {
                sh '''
                curl -s -X POST --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET https://api.mailjet.com/v3.1/send -H "Content-Type:application/json" -d '{
                    "Messages":[
                        {
                            "From": {
                                "Email": "$MAIL_JET_EMAIL_ADDRESS",
                                "Name": "ArpanSahuOne Jenkins Notification"
                            },
                            "To": [
                                {
                                    "Email": "$MY_EMAIL_ADDRESS",
                                    "Name": "Development Team"
                                }
                            ],
                            "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Ran Failed",
                            "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} deployment failed",
                            "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is not deployed, Build Failed </h3> <br> <p> Build Url: ${env.BUILD_URL} </p>"
                        }
                    ]
                }'
                '''
            }
        }
    }
}